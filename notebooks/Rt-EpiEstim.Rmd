---
title: "Effective Reproductive Number"
author: "N T Domínguez, F S Abril, Zulma M Cucunubá"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = here::here())
```


To assess the speed at which an infection spreads in a population is an important task when informing public health response to an epidemic. Reproduction numbers are typical metrics for monitoring and controlling the development of epidemics as they are informative of their spread rate ([Batista M. 2021](https://www.tandfonline.com/doi/full/10.1080/17513758.2021.2001584)). These are strongly related to the serial interval (SI), i.e. the distribution of the time elapsed between symptoms onset of a primary case and that of its secondary cases ([Forsberg White L. et al. 2008](https://pubmed.ncbi.nlm.nih.gov/18058829/)), which is commonly estimated by means of detailed contact tracing data.

# Basic reproduction number

The basic reproduction number $R_0$ represents the average number of secondary cases produced by an infectious individual in a completely susceptible population ([Ferrari et al. 2005](https://www.sciencedirect.com/science/article/abs/pii/S0025556405001501)). Values lesser than $1$ indicates that an outbreak will not cause an epidemic in the absence of imported cases, meanwhile $R_0> 1$ warns about the potential of the disease to produce a large outbreak, indicating a possibly exponential growth. The basic reproductive number is given by ([T. Britton and G. S. Tomba, 2019](https://royalsocietypublishing.org/doi/epdf/10.1098/rsif.2018.0670)):

$$
R_0 = \int_0^\infty \beta(s)ds,
$$
where $\beta(s)$ is the average rate at which an infected individual infects others after a time $s$ from infection. Likelihood based methods are commonly employed for real time estimation of the reproductive number and the SI from case notification and contact tracing data; however, the latter is commonly hard and expensive to collect, which difficults the estimation of the SI in real time scenarios (L. F. White and M. Pagano, 2020).

# Instantaneous Reproductive Number

Although $R_0$ can be useful to characterize the transmissibility of a disease and to predict the size and resources required to face it ([Fraser et al. 2004](https://www.pnas.org/doi/epdf/10.1073/pnas.0307506101)), the assumption of complete susceptibility only holds for early stages of epidemics. The instantaneous reproduction number $R_t$ describes the average number of secondary cases generated by infectious individuals at time $t$ assuming no changes to current conditions. This is commonly employed to characterize spread in real time ([L. F. White and M. Pagano, 2020](https://academic.oup.com/aje/article/190/4/611/5919885)). Assuming that transmission follows a Poisson process ([C. Fraser, 2007](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0000758)), the incidence of cases at the current time $I_t$ is given by the renewal equation ([Cori et al. 2013](https://academic.oup.com/aje/article/178/9/1505/89262)):

$$
I_t \sim Poisson\left(R_t \sum_{\tau=0}^{t-1} I_{t-\tau}\omega_t\right),
$$

where $\omega_t$ represents the SI distribution. This method is implemented in the R package {EpiEstim}, that allows the estimation of $R_t$ from incidence data through parametric and non-parametric methods within a Bayesian framework ([R. K. Nash et al. 2022](https://journals.plos.org/digitalhealth/article?id=10.1371/journal.pdig.0000052)). 

# Computing $R_t$

```{r, message=FALSE, warning=FALSE}
library(dplyr)
library(EpiEstim)
library(ggplot2)
```

## Read data

```{r}
# source("./scripts/download_covid19_data.R")
df_covid19_daily <- read.csv("./data/covid19_cases_deaths_daily.csv") %>%
  mutate(date = as.Date(date))

df_covid19_weekly <- read.csv("./data/covid19_cases_deaths_weekly.csv")
```

## Overview of the data

### Cases
```{r}
scale_factor <- max(df_covid19_daily$cases) / max(df_covid19_daily$cum_cases)

ggplot(
  data = df_covid19_daily %>% 
    filter(city != "Santiago"),
  aes(x = date)
  ) +
  # geom_line(aes(y = cases, color = "cases")) +
  # geom_line(aes(y = scale_factor * cum_cases, color = "cum_cases")) +
  geom_line(aes(y = cases)) +
  geom_line(aes(y = scale_factor * cum_cases)) +
  facet_wrap(~city, scales = "free_y", ncol = 1) +
  scale_y_continuous(sec.axis=sec_axis(~./scale_factor, name="cum_cases")) +
  labs(x = "date") +
  labs(y = "cases", color = "") +
  theme_bw() +
  theme(legend.position="bottom")
```

```{r}
scale_factor <- max(df_covid19_weekly$cases) / max(df_covid19_weekly$cum_cases)

ggplot(
  data = df_covid19_weekly %>% 
    rename(date = epi_week) %>%
    filter(city != "Santiago"),
  aes(x = date, y = cases, group = city)
  ) +
  # geom_line(aes(y = cases, color = "cases")) +
  # geom_point(aes(y = cases, color = "cases")) +
  # geom_line(aes(y = scale_factor * cum_cases, color = "cum_cases")) +
  geom_line(aes(y = cases)) +
  geom_point(aes(y = cases)) +
  geom_line(aes(y = scale_factor * cum_cases)) +
  facet_wrap(~city, scales = "free_y", ncol = 1) +
  scale_y_continuous(sec.axis=sec_axis(~./scale_factor, name="cum_cases")) +
  scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) +
  labs(x = "date") +
  labs(y = "cases", color = "") +
  theme_bw() +
  theme(
    legend.position="bottom",
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
    panel.grid.major = element_blank()
    )
```

### Deaths

```{r}
scale_factor <- max(df_covid19_daily$deaths, na.rm = TRUE) / max(df_covid19_daily$cum_deaths, na.rm = TRUE)

ggplot(data = df_covid19_daily) +
  # geom_line(aes(x = date, y = deaths, color = "deaths")) +
  # geom_line(aes(x = date, y = scale_factor * cum_deaths, color = "cum_deaths")) +
  geom_line(aes(x = date, y = deaths)) +
  geom_line(aes(x = date, y = scale_factor * cum_deaths)) +
  facet_wrap(~city, scales = "free", ncol = 2) +
  labs(x = "date") +
  scale_y_continuous(sec.axis=sec_axis(~./scale_factor, name="cum_deaths")) +
  labs(y = "deaths", color = "") +
  theme_bw() +
  theme(legend.position="bottom")
```

```{r}
scale_factor <- max(df_covid19_weekly$deaths) / max(df_covid19_weekly$cum_deaths)

ggplot(
  data = df_covid19_weekly %>% 
    rename(date = epi_week),
  aes(x = date, y = deaths, group = city)
  ) +
  # geom_line(aes(y = deaths, color = "deaths")) +
  # geom_point(aes(y = deaths, color = "deaths")) +
  # geom_line(aes(y = scale_factor * cum_deaths, color = "cum_deaths")) +
  
  geom_line(aes(y = deaths)) +
  geom_point(aes(y = deaths)) +
  geom_line(aes(y = scale_factor * cum_deaths)) +
  facet_wrap(~city, scales = "free_y", ncol = 2) +
  scale_y_continuous(sec.axis=sec_axis(~./scale_factor, name="cum_deaths")) +
  scale_x_discrete(guide = guide_axis(check.overlap = TRUE)) +
  labs(x = "date") +
  labs(y = "deaths", color = "") +
  theme_bw() +
  theme(
    legend.position="bottom",
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
    axis.ticks = element_blank()
    )
```

## Estimating $R_t$ with {EpiEstim}

### Useful functions

```{r}
# complete missing dates
complete_dates <- function(df) {
  all_dates <- data.frame(
    infection = seq.Date(
      min(df$infection, na.rm = TRUE),
      max(df$infection, na.rm = TRUE),
      by = "day"
    )
  )

  df <- left_join(all_dates, df)
  df <- df %>% replace(is.na(df), 0)
  return(df)
}

compute_rt <- function(
  df_incidence,
  method = "parametric_si",
  mean_si = 6.48,
  std_si = 3.83,
  rt_window = 14,
  incubation_period = 5
) {
  t_start <- seq(incubation_period, nrow(df_incidence) - rt_window)
  t_end <- t_start + rt_window

  rt_data <- estimate_R(
    df_incidence,
    method = method,
    config = make_config(
      list(
        mean_si = mean_si,
        std_si = std_si,
        t_start = t_start,
        t_end = t_end
      )
    )
  )

  df_rt <- rt_data$R
  df_rt$window_start <- min(df_incidence$infection) + df_rt$t_start
  df_rt$window_end <- min(df_incidence$infection) + df_rt$t_end

  return(df_rt)
}
```


### Assuming that dates coincide with onset

```{r}
rt_window <- 14
incubation_period <- 5

df_covid19_daily$infection <- df_covid19_daily$date - incubation_period
```

### Computing $R_t$ (cases)

```{r, message=FALSE, warning=FALSE}
df_rt <- data.frame()
cities <- df_covid19_daily$city %>% unique()
for (city_ in cities){
  print(city_)
  df <- df_covid19_daily %>% filter(city == city_) %>%
    select(c('infection', 'cases')) %>%
    rename(I = cases) %>%
    complete_dates()

  df_rt_ <- df %>% compute_rt(
    rt_window = rt_window,
    incubation_period = incubation_period) %>%
    mutate(city = city_)

  df_rt <- rbind(df_rt, df_rt_)
  rm(df_rt_)
}
df_rt <- df_rt %>% select(c('city', 'window_start', 'window_end', 'Mean(R)', 'Quantile.0.05(R)', 'Quantile.0.975(R)'))
colnames(df_rt) <- c(c('city', 'window_start', 'window_end', 'rt_mean', 'rt_mean_lower', 'rt_mean_upper'))
```

### Plotting the results

```{r}
ggplot(
  data = df_rt %>% 
    filter(city != "Santiago"),
  aes(x = window_end)
  ) +
  geom_line(aes(y = rt_mean)) +
  geom_ribbon(
    aes(
      ymin = .data$rt_mean_lower,
      ymax = .data$rt_mean_upper
    ),
    alpha = 0.4
  ) +
  facet_wrap(~city, scales = "free", ncol = 1) +
  theme_bw()
```

<!-- ### Computing $R_t$ (deaths) -->

```{r, eval=FALSE, echo=FALSE}
df_rt <- data.frame()
cities <- df_covid19_daily$city %>% unique()
for (city_ in cities){
  print(city_)
  df <- df_covid19_daily %>% filter(city == city_) %>%
    select(c('infection', 'deaths')) %>%
    rename(I = deaths) %>%
    complete_dates()

  df_rt_ <- df %>% compute_rt(
    rt_window = rt_window,
    incubation_period = incubation_period) %>%
    mutate(city = city_)

  df_rt <- rbind(df_rt, df_rt_)
  rm(df_rt_)
}
df_rt <- df_rt %>% select(c('city', 'window_start', 'window_end', 'Mean(R)', 'Quantile.0.05(R)', 'Quantile.0.975(R)'))
colnames(df_rt) <- c(c('city', 'window_start', 'window_end', 'rt_mean', 'rt_mean_lower', 'rt_mean_upper'))
```

<!-- ### Plotting the results -->

```{r, eval=FALSE, echo=FALSE}
ggplot(data = df_rt) +
  geom_line(aes(x = window_end, y = rt_mean)) +
  facet_wrap(~city, scales = "free", ncol = 1)
```





